# -*- coding: utf-8 -*-
"""Webcam Face Detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15ZW33GSpEfO7bvZ2wAx_4XCU8LyBCeRK
"""

# Import the library
import cv2

"""First, In the webcam face detection we want to create a class FaceDetector which takes the cascade xml file as input in the **__init __**  method and a instantes called faceCascade as the Cascade Classifier, then the **detect** method which takes video frame , scalFactor, minNeighbors, minSize as the arguments and call the detectMultiScale and outputs the parameters of the rectangle (face in video)"""

# Create the Face Detector class
class FaceDetector:
    def __init__(self, faceCascadePath):
        """
        Calling the Cascade Classifier function in opencv to detect faces by taking the
        haar cascade xml file as the argument (convert serialized xml file (classifier) into
        deseralized classifier)
        """
        self.faceCascade = cv2.CascadeClassifier(faceCascadePath)

    def detect(self, image, scaleFactor=1.2, minNeighbors=5, minSize=(30, 30)):
        rects = self.faceCascade.detectMultiScale(image,
                                                  scaleFactor=scaleFactor,
                                                  minNeighbors=minNeighbors,
                                                  minSize=minSize,
                                                  flags=cv2.CASCADE_SCALE_IMAGE)
        return rects

"""### Parameters used in the detectMultiScale function
**scaleFactor**: How much the image size is reduced at each image scale. This value is used to create the scale pyramid in order to detect faces at multiple scales in the image (some faces may be closer to the foreground, and thus be larger; other faces may be smaller and in the background, thus the usage of varying scales).                                        

**minNeighbors**: How many neighbors each windo w should have for the area in the window to be considered a face. The cascade classifier will detect multiple windows around a face. This parameter controls how many rectangles (neighbors) need to be detected for the window to be labeled a face.

**minSize**: A tuple of width and height (in pixels) indicating the minimum size of the window. Bounding boxes smaller than this size are ignored. It is a good idea to start with (30, 30) and fine-tune from there.
"""

def resize(image, width=None, height=None, inter=cv2.INTER_AREA):
    (h, w) = image.shape[:2]
    dim = None

    if width is None and height is None:
        return image

    if width is None:
        r = height / float(h)
        dim = (int(r * w), height)
    else:
        r = width / float(w)
        dim = (width, int(r * h))

    resized = cv2.resize(image, dim, interpolation=inter)
    return resized

"""Here, we want to resize the video as per the convinence. For that we can create the resize function using OpenCV library which takes the video frame and the width to be resized as the parameters and outputs the resized video frame, we want the webcam should be opened."""

# Create a object for Face Detector class
fd = FaceDetector(r'C:\College learnings\Development\Digilocker_project\Backend\PROJECT_VOTING SYSTEM\Required Models (2_7)\haarcascade_frontalface_default.xml')

# Choosing the video (webcam)
webcam = cv2.VideoCapture(0)

"""The video is represented as the multi frame(more images). So, we want to loop through this all frame to get the video and then we use our detect method in our faceDetector to detect the face in it."""

# Loop through all the frames
while True:
    # read the frames(images) in the video and bool value which says True(grabbed) using read() function
    (grabbed, frame) = webcam.read()

    # Resize the video
    frame = resize(frame, width=500)
    # Convert RGB into Gray Scale
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    # Detect the face in the video and gives back the face as the rectangle (x, y, w, h)
    faceRects = fd.detect(frame,
                          scaleFactor=1.1,
                          minNeighbors=5,
                          minSize=(30, 30))
    # Coping the frames for further pre-processing
    frameClone = frame.copy()

    # Create rectangle shape in the face
    for (x, y, w, h) in faceRects:
        cv2.rectangle(frameClone, (x, y), (x+w, y+h), (0, 255, 0), 2)

    # Show the video
    cv2.imshow("Faces", frameClone)

    # To Close the webcam or video we it is enough
    if cv2.waitKey(1) & 0xFF == ord("q"):
        break

# When everything is done, release the capture
webcam.release()
cv2.destroyAllWindows()

